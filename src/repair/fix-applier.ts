/**
 * Fix Applier Interface
 * Defines the contract for applying automated fixes to test code
 *
 * This module prepares the architecture for future auto-fix functionality:
 * 1. Checkout a new branch
 * 2. Apply recommended fixes
 * 3. Create a pull request
 */

import { FixRecommendation } from '../types';

/**
 * Result of applying a fix
 */
export interface ApplyResult {
  /** Whether the fix was successfully applied */
  success: boolean;
  /** Files that were modified */
  modifiedFiles: string[];
  /** Error message if fix failed */
  error?: string;
  /** Git commit SHA if committed */
  commitSha?: string;
}

/**
 * Result of creating a pull request
 */
export interface PullRequestResult {
  /** Whether the PR was successfully created */
  success: boolean;
  /** PR number */
  prNumber?: number;
  /** PR URL */
  prUrl?: string;
  /** Error message if PR creation failed */
  error?: string;
}

/**
 * Configuration for fix application
 */
export interface FixApplierConfig {
  /** Repository owner */
  owner: string;
  /** Repository name */
  repo: string;
  /** Base branch to create fix branch from */
  baseBranch: string;
  /** GitHub token for API access */
  githubToken: string;
  /** Whether to create a PR automatically */
  createPr: boolean;
  /** Optional PR title prefix */
  prTitlePrefix?: string;
}

/**
 * Interface for applying fixes to codebases
 * Implementations can target different SCM systems (GitHub, GitLab, etc.)
 */
export interface FixApplier {
  /**
   * Check if the fix can be applied
   * Validates that:
   * - Repository is accessible
   * - Base branch exists
   * - User has write permissions
   */
  canApply(recommendation: FixRecommendation): Promise<boolean>;

  /**
   * Apply the recommended fix
   * Creates a new branch and commits the changes
   */
  applyFix(recommendation: FixRecommendation): Promise<ApplyResult>;

  /**
   * Create a pull request with the applied fix
   */
  createPullRequest(
    fix: ApplyResult,
    recommendation: FixRecommendation
  ): Promise<PullRequestResult>;
}

/**
 * Factory function for creating fix appliers
 * Future: Support different implementations (GitHub, GitLab, etc.)
 */
export function createFixApplier(_config: FixApplierConfig): FixApplier {
  // TODO: Implement GitHubFixApplier
  // For now, return a stub that indicates the feature is not yet implemented
  return {
    async canApply(_recommendation: FixRecommendation): Promise<boolean> {
      // Auto-fix is not yet implemented
      return false;
    },

    async applyFix(_recommendation: FixRecommendation): Promise<ApplyResult> {
      return {
        success: false,
        modifiedFiles: [],
        error: 'Auto-fix feature is not yet implemented'
      };
    },

    async createPullRequest(
      _fix: ApplyResult,
      _recommendation: FixRecommendation
    ): Promise<PullRequestResult> {
      return {
        success: false,
        error: 'Auto-fix feature is not yet implemented'
      };
    }
  };
}

/**
 * Generate a branch name for a fix
 */
export function generateFixBranchName(
  testFile: string,
  timestamp: Date = new Date()
): string {
  const sanitizedFile = testFile
    .replace(/[^a-zA-Z0-9]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 50);

  const dateStr = timestamp.toISOString().slice(0, 10).replace(/-/g, '');
  return `fix/triage-agent-${sanitizedFile}-${dateStr}`;
}

/**
 * Generate a commit message for a fix
 */
export function generateFixCommitMessage(recommendation: FixRecommendation): string {
  const files = recommendation.proposedChanges.map(c => c.file).join(', ');
  return `fix(test): ${recommendation.summary.slice(0, 50)}

Automated fix generated by adept-triage-agent.

Files modified: ${files}
Confidence: ${recommendation.confidence}%

${recommendation.reasoning}
`;
}
