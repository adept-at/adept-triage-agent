/**
 * Fix Applier Implementation
 * Applies automated fixes to test code by creating branches and committing changes
 * Uses GitHub REST API (no local git repository required)
 */

import * as core from '@actions/core';
import { Octokit } from '@octokit/rest';
import { FixRecommendation } from '../types';
import { AUTO_FIX } from '../config/constants';

/**
 * Result of applying a fix
 */
export interface ApplyResult {
  /** Whether the fix was successfully applied */
  success: boolean;
  /** Files that were modified */
  modifiedFiles: string[];
  /** Error message if fix failed */
  error?: string;
  /** Git commit SHA if committed */
  commitSha?: string;
  /** Branch name that was created */
  branchName?: string;
}

/**
 * Configuration for fix application
 */
export interface FixApplierConfig {
  /** Octokit instance for GitHub API calls */
  octokit: Octokit;
  /** Repository owner */
  owner: string;
  /** Repository name */
  repo: string;
  /** Base branch to create fix branch from */
  baseBranch: string;
  /** Minimum confidence threshold to apply fix */
  minConfidence: number;
}

/**
 * Interface for applying fixes to codebases
 */
export interface FixApplier {
  /**
   * Check if the fix can be applied based on confidence threshold
   */
  canApply(recommendation: FixRecommendation): boolean;

  /**
   * Apply the recommended fix
   * Creates a new branch, applies changes, commits, and pushes
   */
  applyFix(recommendation: FixRecommendation): Promise<ApplyResult>;
}

/**
 * GitHub-based fix applier using GitHub REST API
 * Does not require a local git repository
 */
export class GitHubFixApplier implements FixApplier {
  private config: FixApplierConfig;

  constructor(config: FixApplierConfig) {
    this.config = config;
  }

  /**
   * Check if the fix can be applied based on confidence threshold
   */
  canApply(recommendation: FixRecommendation): boolean {
    if (recommendation.confidence < this.config.minConfidence) {
      core.info(
        `Fix confidence (${recommendation.confidence}%) is below threshold (${this.config.minConfidence}%)`
      );
      return false;
    }

    if (!recommendation.proposedChanges || recommendation.proposedChanges.length === 0) {
      core.info('No proposed changes in fix recommendation');
      return false;
    }

    return true;
  }

  /**
   * Apply the recommended fix by creating a branch and committing changes via GitHub API
   */
  async applyFix(recommendation: FixRecommendation): Promise<ApplyResult> {
    const modifiedFiles: string[] = [];
    let branchName = '';
    let lastCommitSha = '';

    try {
      const { octokit, owner, repo, baseBranch } = this.config;

      // Get the test file from the first proposed change
      const testFile = recommendation.proposedChanges[0]?.file || 'unknown';
      branchName = generateFixBranchName(testFile);

      core.info(`Creating fix branch: ${branchName}`);

      // Get the base branch SHA
      const baseBranchRef = await octokit.git.getRef({
        owner,
        repo,
        ref: `heads/${baseBranch}`,
      });
      const baseSha = baseBranchRef.data.object.sha;
      core.debug(`Base branch ${baseBranch} SHA: ${baseSha}`);

      // Create the new branch
      await octokit.git.createRef({
        owner,
        repo,
        ref: `refs/heads/${branchName}`,
        sha: baseSha,
      });
      core.info(`Created branch: ${branchName}`);

      // Apply each proposed change
      for (const change of recommendation.proposedChanges) {
        const filePath = change.file;

        try {
          // Get the current file content from the new branch
          const fileResponse = await octokit.repos.getContent({
            owner,
            repo,
            path: filePath,
            ref: branchName,
          });

          // Ensure we got a file (not a directory)
          if (Array.isArray(fileResponse.data) || fileResponse.data.type !== 'file') {
            core.warning(`${filePath} is not a file, skipping`);
            continue;
          }

          const currentContent = Buffer.from(fileResponse.data.content, 'base64').toString('utf-8');
          const fileSha = fileResponse.data.sha;

          // Apply the change (simple string replacement)
          if (change.oldCode && change.newCode) {
            const newContent = currentContent.replace(change.oldCode, change.newCode);

            if (newContent === currentContent) {
              core.warning(`Could not find old code to replace in ${filePath}`);
              continue;
            }

            // Commit the change
            const commitMessage = `fix(test): ${change.justification.slice(0, 50)}

Automated fix generated by adept-triage-agent.

File: ${filePath}
Confidence: ${recommendation.confidence}%`;

            const updateResponse = await octokit.repos.createOrUpdateFileContents({
              owner,
              repo,
              path: filePath,
              message: commitMessage,
              content: Buffer.from(newContent).toString('base64'),
              sha: fileSha,
              branch: branchName,
            });

            lastCommitSha = updateResponse.data.commit.sha || '';
            modifiedFiles.push(filePath);
            core.info(`Modified: ${filePath}`);
          }
        } catch (fileError) {
          const errorMsg = fileError instanceof Error ? fileError.message : String(fileError);
          core.warning(`Failed to modify ${filePath}: ${errorMsg}`);
        }
      }

      if (modifiedFiles.length === 0) {
        // Clean up - delete the branch we created
        try {
          await octokit.git.deleteRef({
            owner,
            repo,
            ref: `heads/${branchName}`,
          });
          core.debug(`Cleaned up branch ${branchName}`);
        } catch {
          // Ignore cleanup errors
        }

        return {
          success: false,
          modifiedFiles: [],
          error: 'No files were successfully modified',
        };
      }

      core.info(`Successfully created fix branch: ${branchName}`);
      core.info(`Commit SHA: ${lastCommitSha}`);

      return {
        success: true,
        modifiedFiles,
        commitSha: lastCommitSha,
        branchName,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      core.error(`Failed to apply fix: ${errorMessage}`);

      // Try to clean up the branch if we created it
      if (branchName) {
        try {
          await this.config.octokit.git.deleteRef({
            owner: this.config.owner,
            repo: this.config.repo,
            ref: `heads/${branchName}`,
          });
        } catch {
          // Ignore cleanup errors
        }
      }

      return {
        success: false,
        modifiedFiles,
        error: errorMessage,
      };
    }
  }
}

/**
 * Factory function for creating fix appliers
 */
export function createFixApplier(config: FixApplierConfig): FixApplier {
  return new GitHubFixApplier(config);
}

/**
 * Generate a branch name for a fix
 */
export function generateFixBranchName(
  testFile: string,
  timestamp: Date = new Date()
): string {
  const sanitizedFile = testFile
    .replace(/[^a-zA-Z0-9]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 50);

  const dateStr = timestamp.toISOString().slice(0, 10).replace(/-/g, '');
  return `${AUTO_FIX.BRANCH_PREFIX}${sanitizedFile}-${dateStr}`;
}

/**
 * Generate a commit message for a fix
 */
export function generateFixCommitMessage(recommendation: FixRecommendation): string {
  const files = recommendation.proposedChanges.map(c => c.file).join(', ');
  const summary = recommendation.summary.slice(0, 50);

  return `fix(test): ${summary}

Automated fix generated by adept-triage-agent.

Files modified: ${files}
Confidence: ${recommendation.confidence}%

${recommendation.reasoning}`;
}
